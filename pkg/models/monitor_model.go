// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MonitorModel monitor model
//
// swagger:model MonitorModel
type MonitorModel struct {

	// Annotations to attach to the alert.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty"`

	// Whether the alert should auto-resolve.
	AutoResolve bool `json:"autoResolve,omitempty" yaml:"autoResolve,omitempty"`

	// Category of the monitor.
	Category string `json:"category,omitempty" yaml:"category,omitempty"`

	// State to enter if execution fails.
	// Enum: ["OK"," Error"," Alerting"]
	ExecutionErrorState string `json:"executionErrorState,omitempty" yaml:"executionErrorState,omitempty"`

	// Whether the monitor is paused.
	IsPaused bool `json:"isPaused,omitempty" yaml:"isPaused,omitempty"`

	// Labels to attach to the monitor/alert.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`

	// Type of measurement (state or event).
	// Enum: ["state"," event"]
	MeasurementType string `json:"measurementType,omitempty" yaml:"measurementType,omitempty"`

	// State to enter if no data is returned.
	// Enum: ["OK"," NoData"," Alerting"]
	NoDataState string `json:"noDataState,omitempty" yaml:"noDataState,omitempty"`

	// Routing information.
	Routing []string `json:"routing" yaml:"routing"`

	// Severity level (e.g., critical, warning, info).
	Severity string `json:"severity,omitempty" yaml:"severity,omitempty"`

	// Team associated with the monitor.
	Team string `json:"team,omitempty" yaml:"team,omitempty"`

	// Title of the monitor.
	// Required: true
	Title *string `json:"title" yaml:"title"`

	// catalog
	Catalog *CatalogModel `json:"catalog,omitempty" yaml:"catalog,omitempty"`

	// display
	Display *DisplayModel `json:"display,omitempty" yaml:"display,omitempty"`

	// evaluation interval
	EvaluationInterval *EvaluationInterval `json:"evaluationInterval,omitempty" yaml:"evaluationInterval,omitempty"`

	// model
	Model *Model `json:"model,omitempty" yaml:"model,omitempty"`
}

// Validate validates this monitor model
func (m *MonitorModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExecutionErrorState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeasurementType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoDataState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCatalog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvaluationInterval(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModel(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var monitorModelTypeExecutionErrorStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OK"," Error"," Alerting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		monitorModelTypeExecutionErrorStatePropEnum = append(monitorModelTypeExecutionErrorStatePropEnum, v)
	}
}

const (

	// MonitorModelExecutionErrorStateOK captures enum value "OK"
	MonitorModelExecutionErrorStateOK string = "OK"

	// MonitorModelExecutionErrorStateError captures enum value " Error"
	MonitorModelExecutionErrorStateError string = " Error"

	// MonitorModelExecutionErrorStateAlerting captures enum value " Alerting"
	MonitorModelExecutionErrorStateAlerting string = " Alerting"
)

// prop value enum
func (m *MonitorModel) validateExecutionErrorStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, monitorModelTypeExecutionErrorStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MonitorModel) validateExecutionErrorState(formats strfmt.Registry) error {
	if swag.IsZero(m.ExecutionErrorState) { // not required
		return nil
	}

	// value enum
	if err := m.validateExecutionErrorStateEnum("executionErrorState", "body", m.ExecutionErrorState); err != nil {
		return err
	}

	return nil
}

var monitorModelTypeMeasurementTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["state"," event"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		monitorModelTypeMeasurementTypePropEnum = append(monitorModelTypeMeasurementTypePropEnum, v)
	}
}

const (

	// MonitorModelMeasurementTypeState captures enum value "state"
	MonitorModelMeasurementTypeState string = "state"

	// MonitorModelMeasurementTypeEvent captures enum value " event"
	MonitorModelMeasurementTypeEvent string = " event"
)

// prop value enum
func (m *MonitorModel) validateMeasurementTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, monitorModelTypeMeasurementTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MonitorModel) validateMeasurementType(formats strfmt.Registry) error {
	if swag.IsZero(m.MeasurementType) { // not required
		return nil
	}

	// value enum
	if err := m.validateMeasurementTypeEnum("measurementType", "body", m.MeasurementType); err != nil {
		return err
	}

	return nil
}

var monitorModelTypeNoDataStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OK"," NoData"," Alerting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		monitorModelTypeNoDataStatePropEnum = append(monitorModelTypeNoDataStatePropEnum, v)
	}
}

const (

	// MonitorModelNoDataStateOK captures enum value "OK"
	MonitorModelNoDataStateOK string = "OK"

	// MonitorModelNoDataStateNoData captures enum value " NoData"
	MonitorModelNoDataStateNoData string = " NoData"

	// MonitorModelNoDataStateAlerting captures enum value " Alerting"
	MonitorModelNoDataStateAlerting string = " Alerting"
)

// prop value enum
func (m *MonitorModel) validateNoDataStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, monitorModelTypeNoDataStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MonitorModel) validateNoDataState(formats strfmt.Registry) error {
	if swag.IsZero(m.NoDataState) { // not required
		return nil
	}

	// value enum
	if err := m.validateNoDataStateEnum("noDataState", "body", m.NoDataState); err != nil {
		return err
	}

	return nil
}

func (m *MonitorModel) validateTitle(formats strfmt.Registry) error {

	if err := validate.Required("title", "body", m.Title); err != nil {
		return err
	}

	return nil
}

func (m *MonitorModel) validateCatalog(formats strfmt.Registry) error {
	if swag.IsZero(m.Catalog) { // not required
		return nil
	}

	if m.Catalog != nil {
		if err := m.Catalog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("catalog")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("catalog")
			}
			return err
		}
	}

	return nil
}

func (m *MonitorModel) validateDisplay(formats strfmt.Registry) error {
	if swag.IsZero(m.Display) { // not required
		return nil
	}

	if m.Display != nil {
		if err := m.Display.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("display")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("display")
			}
			return err
		}
	}

	return nil
}

func (m *MonitorModel) validateEvaluationInterval(formats strfmt.Registry) error {
	if swag.IsZero(m.EvaluationInterval) { // not required
		return nil
	}

	if m.EvaluationInterval != nil {
		if err := m.EvaluationInterval.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("evaluationInterval")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("evaluationInterval")
			}
			return err
		}
	}

	return nil
}

func (m *MonitorModel) validateModel(formats strfmt.Registry) error {
	if swag.IsZero(m.Model) { // not required
		return nil
	}

	if m.Model != nil {
		if err := m.Model.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("model")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("model")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this monitor model based on the context it is used
func (m *MonitorModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCatalog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDisplay(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEvaluationInterval(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MonitorModel) contextValidateCatalog(ctx context.Context, formats strfmt.Registry) error {

	if m.Catalog != nil {

		if swag.IsZero(m.Catalog) { // not required
			return nil
		}

		if err := m.Catalog.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("catalog")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("catalog")
			}
			return err
		}
	}

	return nil
}

func (m *MonitorModel) contextValidateDisplay(ctx context.Context, formats strfmt.Registry) error {

	if m.Display != nil {

		if swag.IsZero(m.Display) { // not required
			return nil
		}

		if err := m.Display.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("display")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("display")
			}
			return err
		}
	}

	return nil
}

func (m *MonitorModel) contextValidateEvaluationInterval(ctx context.Context, formats strfmt.Registry) error {

	if m.EvaluationInterval != nil {

		if swag.IsZero(m.EvaluationInterval) { // not required
			return nil
		}

		if err := m.EvaluationInterval.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("evaluationInterval")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("evaluationInterval")
			}
			return err
		}
	}

	return nil
}

func (m *MonitorModel) contextValidateModel(ctx context.Context, formats strfmt.Registry) error {

	if m.Model != nil {

		if swag.IsZero(m.Model) { // not required
			return nil
		}

		if err := m.Model.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("model")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("model")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MonitorModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MonitorModel) UnmarshalBinary(b []byte) error {
	var res MonitorModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
